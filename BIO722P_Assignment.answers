{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Bio722P Coding for Bioscientists Final Assignment, 2025/26"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "This assignment counts towards 100% of the marks for this module. The assignment is divided into four questions."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Student name and number\n",
    "Enter your full name and student number in the cell below"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "full name: Declan Michael Courtney\n",
    "\n",
    "student number: 251089517"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "\n",
    "## Deadline and submission\n",
    "\n",
    "Complete this notebook with your code, compress it together with any additional files and submit it as a single .zip or .gz file through the QMPlus page by the following deadline:\n",
    "\n",
    "    Friday Oct 31st 2025, 16:00\n",
    "\n",
    "\n",
    "## Submission checklist\n",
    "\n",
    "* Notebook is written in Python 3 and can be opened and run on the QMUL JupyterHub.\n",
    "* Any import statements are grouped in the cell provided at the end of this introduction; there should be no other import statements in the notebook.\n",
    "* Notebook functions pass all tests when cells are run with a fresh kernel from top to bottom.\n",
    "* Notebook only contains well commented answer code and the original tests. Please remove your own test code.\n",
    "* Notebook includes the full name and student number of the author.\n",
    "* Zip file containing the notebook is free from errors.\n",
    "\n",
    "Please refrain from editing the text of the assignment and the test code provided. Feel free to insert text or code cells as needed, but please clean up rough work that you do not wish to be marked.\n",
    "\n",
    "## Marking\n",
    "\n",
    "Your work will be marked based on:\n",
    "\n",
    "        completeness and correctness: 70% (may be assessed automatically)\n",
    "        coding style: 30% (holistic assessment)\n",
    "\n",
    "For automatic marking to function appropriately, each of your answers **must** pass the tests provided when running the notebook from top to bottom on a fresh kernel. Code that does not pass the tests or is not run (directly or indirectly, e.g. a function calling another function) by the functions you are asked to implement will **not** be marked.\n",
    "\n",
    "The test code provided with each question does **not** ensure that your submission is correct; it only ensures that it can be marked automatically. You will need to test your code independently for correctness; however, please remove your test code from your final submission, and do not submit any test data; the marking script will test your code with its own choice of data.\n",
    "\n",
    "## How to answer questions\n",
    "\n",
    "This assignment contains four questions, that carry different weights and can in principle be tackled in any order. However, we suggest that you answer Question 2 before attempting Question 3.\n",
    "\n",
    "Each question will require you to code a few functions or classes. As you progress through the subquestions, you may have to rely on your answer to previous subquestions to perform some operations. Please call the relevant functions and avoid duplicating code.  \n",
    "\n",
    "Do not remove or edit the comments at the top of the answer cells - marking scripts depend on them.\n",
    "\n",
    "\n",
    "## Use of libraries and language features\n",
    "\n",
    "Most of the assignment can be solved using built in functions and types; you are free to import any module or package from the **Python standard library only** where required. Third party or non-standard libraries (including Biopython, numpy and Pandas) are not allowed except where specifically indicated. **In your solution, you should only use Python statements and constructs covered in the module**."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Please put any import statements here, according to the example.\n",
    "# Example:\n",
    "import math # this would obviously be uncommented if you are importing the math library\n",
    "from Bio.Align import substitution_matrices"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Preliminary reading\n",
    "\n",
    "Please read the PDF file ```BIO722P_Assignment_Background.pdf``` distributed with this assigment carefully before you start coding."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 1: Translation and reading frames [20 marks]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.a: Reading frames\n",
    "Write a function ```translate``` that takes a string containing a DNA sequence as its input and outputs a Python dictionary containing the translation of the sequence in all possible reading frames. The keys of the dictionary should be ```f1```, ```f2```, ```f3``` for the three forward frames and ```r1```, ```r2``` and ```r3``` for the reverse reading frames; the value of each key should be the translation of the sequence in the corresponding frame.\n",
    "For simplicity and ease of debugging, **do not complement the sequence** when computing the reverse reading frames; just reverse it. Use an asterisk (```*```) to represent stop codons. Always translate the entire sequence."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1a_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def translate(seq: str) -> dict:\n",
    "    \"\"\"\n",
    "    Translate a DNA sequence into all six reading frames.\n",
    "    Unknown codons become 'X'. Stop codons are '*'.\n",
    "    \"\"\"\n",
    "    seq = seq.upper().strip()\n",
    "\n",
    "    table = {\n",
    "        \"TTT\":\"F\",\"TTC\":\"F\",\"TTA\":\"L\",\"TTG\":\"L\",\n",
    "        \"CTT\":\"L\",\"CTC\":\"L\",\"CTA\":\"L\",\"CTG\":\"L\",\n",
    "        \"ATT\":\"I\",\"ATC\":\"I\",\"ATA\":\"I\",\"ATG\":\"M\",\n",
    "        \"GTT\":\"V\",\"GTC\":\"V\",\"GTA\":\"V\",\"GTG\":\"V\",\n",
    "        \"TCT\":\"S\",\"TCC\":\"S\",\"TCA\":\"S\",\"TCG\":\"S\",\n",
    "        \"CCT\":\"P\",\"CCC\":\"P\",\"CCA\":\"P\",\"CCG\":\"P\",\n",
    "        \"ACT\":\"T\",\"ACC\":\"T\",\"ACA\":\"T\",\"ACG\":\"T\",\n",
    "        \"GCT\":\"A\",\"GCC\":\"A\",\"GCA\":\"A\",\"GCG\":\"A\",\n",
    "        \"TAT\":\"Y\",\"TAC\":\"Y\",\"TAA\":\"*\",\"TAG\":\"*\",\n",
    "        \"CAT\":\"H\",\"CAC\":\"H\",\"CAA\":\"Q\",\"CAG\":\"Q\",\n",
    "        \"AAT\":\"N\",\"AAC\":\"N\",\"AAA\":\"K\",\"AAG\":\"K\",\n",
    "        \"GAT\":\"D\",\"GAC\":\"D\",\"GAA\":\"E\",\"GAG\":\"E\",\n",
    "        \"TGT\":\"C\",\"TGC\":\"C\",\"TGA\":\"*\",\"TGG\":\"W\",\n",
    "        \"CGT\":\"R\",\"CGC\":\"R\",\"CGA\":\"R\",\"CGG\":\"R\",\n",
    "        \"AGT\":\"S\",\"AGC\":\"S\",\"AGA\":\"R\",\"AGG\":\"R\",\n",
    "        \"GGT\":\"G\",\"GGC\":\"G\",\"GGA\":\"G\",\"GGG\":\"G\"\n",
    "    }\n",
    "\n",
    "    def tr(s, offset):\n",
    "        usable = len(s) - ((len(s) - offset) % 3)\n",
    "        aa = \"\"\n",
    "        for i in range(offset, usable, 3):\n",
    "            codon = s[i:i+3]\n",
    "            aa += table.get(codon, \"X\")\n",
    "        return aa\n",
    "\n",
    "    f1, f2, f3 = tr(seq, 0), tr(seq, 1), tr(seq, 2)\n",
    "    rev = seq[::-1]  # reverse only (no complement)\n",
    "    r1, r2, r3 = tr(rev, 0), tr(rev, 1), tr(rev, 2)\n",
    "\n",
    "    return {\"f1\": f1, \"f2\": f2, \"f3\": f3,\n",
    "            \"r1\": r1, \"r2\": r2, \"r3\": r3}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'translate' in globals(), \"translate not defined - check your spelling\"\n",
    "assert inspect.isfunction(translate), \"translate is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.b: Locating an ORF\n",
    "\n",
    "Write a function called ```openReadingFrame``` that takes a string containing an aminoacid sequence as its argument and returns a string containing the aminoacids between the first Methionine (included) and the first STOP codon that follows it (excluded). Assume the stop codon is represented by an asterisk (```*```) as would be returned by ```translate``` above. If either the Methionine or the STOP codon are missing, your function should return an empty string."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1b_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def openReadingFrame(aa_seq):\n",
    "    # find first M (start codon)\n",
    "    start = aa_seq.find(\"M\")\n",
    "    if start == -1:\n",
    "        return \"\"\n",
    "\n",
    "    # find next * (stop codon)\n",
    "    stop = aa_seq.find(\"*\", start)\n",
    "    if stop == -1:\n",
    "        return \"\"\n",
    "\n",
    "    return aa_seq[start:stop]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'openReadingFrame' in globals(), \"openReadingFrame not defined - check your spelling\"\n",
    "assert inspect.isfunction(openReadingFrame), \"openReadingFrame is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.c: Translating a sequence \n",
    "\n",
    "Write a function called ```candidateProtein``` that takes a string containing a DNA sequence as its input and returns the string of aminoacids corresponding to the longest ORF among those extracted by ```openReadingFrame``` above (ie, ignoring the possibility that there may be more than one ORF in any given frame)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1c_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def candidateProtein(dna_seq):\n",
    "    # clean input\n",
    "    dna_seq = dna_seq.upper().strip()\n",
    "\n",
    "    # translate in all 6 frames (uses your translate() from Q1.a)\n",
    "    frames = translate(dna_seq)\n",
    "\n",
    "    # collect first ORF from each frame (uses your openReadingFrame() from Q1.b)\n",
    "    candidates = []\n",
    "    for aa_seq in frames.values():\n",
    "        orf = openReadingFrame(aa_seq)\n",
    "        candidates.append(orf)\n",
    "\n",
    "    # pick the longest ORF; if tie, keep the first one\n",
    "    best = \"\"\n",
    "    for orf in candidates:\n",
    "        if len(orf) > len(best):\n",
    "            best = orf\n",
    "\n",
    "    return best\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'candidateProtein' in globals(), \"candidateProtein not defined - check your spelling\"\n",
    "assert inspect.isfunction(candidateProtein), \"candidateProtein is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.d: Reading a FASTA file\n",
    "\n",
    "Write a function called ```readFASTAseq``` that takes as its argument the name of a file.  When passed the name of a FASTA file containing a single sequence, the function should read the file, discard the header and return the sequence as an uppercase string.\n",
    "(**NOTE**: This subquestion is shared with Question 2 and will be marked as part of Question 2)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1d_ans - Your answer here - do not edit this comment\n",
    "Def readFASTAseq(filename)\n",
    "#open the file\n",
    "\tSeq = “”\n",
    "\t\tWith open(filename) as f:\n",
    "#skip header line\n",
    "\t\t\tFor line in f\n",
    "\t\t\t\tIf not line.startswith(“>”):\n",
    "\t\t\t\t\tSeq = seq + line.strip()\n",
    "\t\t\tReturn seq.upper()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'readFASTAseq' in globals(), \"readFASTAseq not defined - check your spelling\"\n",
    "assert inspect.isfunction(readFASTAseq), \"readFASTAseq is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.e: Writing a FASTA file \n",
    "\n",
    "Write a function called ```writeFASTA``` that takes three string arguments called, in the order, ```sequence```, ```description``` and ```filename```. Argument ```sequence``` should contain an aminoacid sequence. Argument ```description``` should contain a description (eg name of protein, organism, etc). Argument ```filename``` should contain a file name. Your code should create the file with the name requested in the current working directory, write to it the description as a FASTA header (i.e. starting with the character ```>```) and write the sequence to the file. Long sequences should be formatted over multiple lines. The function should not return any value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1e_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def writeFASTA(sequence, description, filename):\n",
    "    f = open(filename, 'w')\n",
    "    f.write(\">\" + description + \"\\n\")\n",
    "    for i in range(0, len(sequence), 60):\n",
    "        f.write(sequence[i:i+60] + \"\\n\")\n",
    "    f.close()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'writeFASTA' in globals(), \"writeFASTA not defined - check your spelling\"\n",
    "assert inspect.isfunction(writeFASTA), \"writeFASTA is not a function\"\n",
    "_sig=inspect.signature(writeFASTA)\n",
    "for _par in ['sequence', 'description', 'filename']:\n",
    "    assert _par in _sig.parameters, f\"writeFASTA does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 1.f: Putting it all together \n",
    "\n",
    "Write a function called ```maximalORF``` that takes as its argument string ```inputfile``` containing the name of an input file, string ```outputfile``` with the name of an output file and string  ```proteinname``` with a description of a candidate protein. The function should read a DNA sequence from the input file and write the candidate protein corresponding to the longest ORF (as determined in Question 1.c) to the output file, in FASTA format. The string supplied in ```proteinname``` should provide the header of the FASTA file. The function should not return any value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q1f_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def maximalORF(inputfile, outputfile, proteinname):\n",
    "    # get DNA sequence from FASTA\n",
    "    dna = readFASTAseq(inputfile)\n",
    "\n",
    "    # get longest ORF as amino acids\n",
    "    prot = candidateProtein(dna)\n",
    "\n",
    "    # write out as FASTA with given header\n",
    "    writeFASTA(prot, proteinname, outputfile)\n",
    "    # no return\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'maximalORF' in globals(), \"maximalORF not defined - check your spelling\"\n",
    "assert inspect.isfunction(maximalORF), \"maximalORF is not a function\"\n",
    "_sig=inspect.signature(maximalORF)\n",
    "for _par in ['inputfile', 'outputfile', 'proteinname']:\n",
    "    assert _par in _sig.parameters, f\"maximalORF does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 2: Classification of aminoacids [15 marks]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 2.a: Reading a FASTA file\n",
    "\n",
    "Write a function called ```readFASTAseq``` that takes as its argument the name of a file.  When passed the name of a FASTA file containing a single sequence, the function should read the file, discard the header and return the sequence as an uppercase string."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q2a_ans - Your answer here - do not edit this comment\n",
    "def readFASTAseq(filename):\n",
    "    seq = \"\"\n",
    "    f = open(filename)\n",
    "    for line in f:\n",
    "        if not line.startswith(\">\"):\n",
    "            seq = seq + line.strip()\n",
    "    f.close()\n",
    "    return seq.upper()\n",
    "\n",
    "# NOTE: if you have already written this function as part of Q2(d) above,\n",
    "# leave this cell as is. Marks will in any case be credited to \n",
    "# this question. If you include a new definition here, it will override\n",
    "# the one given in Q2(d) above for the purpose of marking both questions.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'readFASTAseq' in globals(), \"readFASTAseq not defined - check your spelling\"\n",
    "assert inspect.isfunction(readFASTAseq), \"readFASTAseq is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 2.b: Aminoacid usage statistics \n",
    "\n",
    "Write a function called ```AAtypes``` that takes as its argument a string containing a sequence of aminoacids. The function should compute, for each protein, the fraction of aminoacids that are polar, small and hydrophobic and return that as a tuple. For instance, if the chain of a protein contains 35% polar residues, 15% small and 50% hydrophobic residues, the function should return ```(0.35, 0.15, 0.5)``` (the order is important). Refer to the Venn diagram in the Assessment Background file for the classification of aminoacids (other Venn diagrams may differ).  Note that some aminoacids belong to more than one category, so that the sum of these three numbers can be larger than 1."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q2b_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def AAtypes(aa_seq):\n",
    "    p = polar = \"CDEHKNQRSTY\"\n",
    "    s = small = \"ACDGNPSTV\"\n",
    "    h = hydrophobic = \"ACFILMVWY\"\n",
    "\n",
    "    p = 0\n",
    "    s = 0\n",
    "    h = 0\n",
    "\n",
    "    for aa in aa_seq:\n",
    "        if aa in polar:\n",
    "            p = p + 1\n",
    "        if aa in small:\n",
    "            s = s + 1\n",
    "        if aa in hydrophobic:\n",
    "            h = h + 1\n",
    "\n",
    "    total = len(aa_seq)\n",
    "    return (p/total, s/total, h/total)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'AAtypes' in globals(), \"AAtypes not defined - check your spelling\"\n",
    "assert inspect.isfunction(AAtypes), \"AAtypes is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 2.c: Processing multiple sequences\n",
    "\n",
    "Write a function called ```AAtypetable``` that takes a list of strings called ```filelist``` and a separate string called ```outputfile```. Each element of ```filelist``` represents the name of a FASTA file containing an aminoacid sequence. For each filename, the function should load the sequence, compute the fraction of aminoacids that are polar, small and/or hydrophobic, and finally output this to the text file specified by ```outputfile``` in CSV (comma-separated values) tabular format. The table should contain, on each line, the name of the input file and then the percentages of polar, small and hydrophobic residues (in that order). Include a comment at the beginning of the file that starts with a ```#``` and specifies the content of each column, as follows (numbers and file names shown here are random):\n",
    "```\n",
    "# Filename,Polar,Small,Hydrophobic\n",
    "Pxxx.fasta,0.52,0.22,0.33\n",
    "Qx3Z.fas,0.47,0.35,0.38\n",
    "...\n",
    "```\n",
    "\n",
    "Include at least two decimal places in your output; do not add any quotes or other spurious characters. If some of the files in ```filelist``` do not exist, contain invalid data or otherwise cause an error, your function should ignore those files and continue. However, the names of those files should be returned by your function in a list. If all files are processed without errors your function should return an empty list.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q2c_ans - Your answer here - do not edit this comment\n",
    "def AAtypetable(filelist, outputfile):\n",
    "    bad = []\n",
    "    with open(outputfile, 'w') as out:\n",
    "        out.write(\"# Filename,Polar,Small,Hydrophobic\\n\")\n",
    "        for fname in filelist:\n",
    "            try:\n",
    "                seq = readFASTAseq(fname)          # reuse my FASTA reader\n",
    "                if len(seq) == 0:\n",
    "                    raise ValueError(\"empty sequence\")\n",
    "\n",
    "                p, s, h = AAtypes(seq)              # reuse my AA types function\n",
    "\n",
    "                # format with at least 2 decimals (no quotes)\n",
    "                line = fname + \",\" + f\"{p:.2f}\" + \",\" + f\"{s:.2f}\" + \",\" + f\"{h:.2f}\" + \"\\n\"\n",
    "                out.write(line)\n",
    "\n",
    "            except Exception:\n",
    "                bad.append(fname)\n",
    "                # continue to next file\n",
    "                continue\n",
    "\n",
    "    return bad\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'AAtypetable' in globals(), \"AAtypetable not defined - check your spelling\"\n",
    "assert inspect.isfunction(AAtypetable), \"AAtypetable is not a function\"\n",
    "_sig=inspect.signature(AAtypetable)\n",
    "for _par in ['filelist', 'outputfile']:\n",
    "    assert _par in _sig.parameters, f\"AAtypetable does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 3: Clustering proteins based on aminoacid usage [25 marks]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 3.a: Computing the distance between 2 vectors "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Write a function called ```distance``` that takes two tuples of ```float``` of equal length and a string ```metric``` as its arguments. The function should return the distance between the two tuples, considered as vectors in a space of dimensionality equal to the length of the tuples. The distance returned should be the [Manhattan distance](https://en.wikipedia.org/wiki/Taxicab_geometry#Formal_definition) if the value of ```metric``` is ```\"l1\"```, and the [Euclidean distance](https://en.wikipedia.org/wiki/Euclidean_distance#Higher_dimensions) if it is ```\"l2\"```. Other values of ```metric``` should result in a ValueError being raised. Your function should also raise a custom exception ```DimensionalityException``` if the two tuples passed are not of the same length, or if they are both empty; otherwise it should return a ```float```.\n",
    "\n",
    "You are asked to define ```DimensionalityException``` in such a way that it can be created without passing any argument to its constructor."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q3a1_ans - define DimensionalityException here - do not edit this comment\n",
    "\n",
    "class DimensionalityException(Exception):\n",
    "    pass\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q3a2_ans - define distance here - do not edit this comment\n",
    "check lengths\n",
    "    if len(t1) != len(t2) or len(t1) == 0:\n",
    "        raise DimensionalityException()\n",
    "\n",
    "    # Manhattan (L1)\n",
    "    if metric == \"l1\":\n",
    "        total = 0.0\n",
    "        for i in range(len(t1)):\n",
    "            total = total + abs(t1[i] - t2[i])\n",
    "        return total\n",
    "\n",
    "    # Euclidean (L2)\n",
    "    elif metric == \"l2\":\n",
    "        total = 0.0\n",
    "        for i in range(len(t1)):\n",
    "            diff = t1[i] - t2[i]\n",
    "            total = total + diff**2\n",
    "        return total**0.5\n",
    "\n",
    "    # invalid metric\n",
    "    else:\n",
    "        raise ValueError(\"Invalid metric type\")\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert \"DimensionalityException\" in globals(), \"DimensionalityException not defined\"\n",
    "assert 'distance' in globals(), \"distance not defined - check your spelling\"\n",
    "assert inspect.isfunction(distance), \"distance is not a function\"\n",
    "_sig=inspect.signature(distance)\n",
    "for _par in ['veca', 'vecb', 'metric']:\n",
    "    assert _par in _sig.parameters, f\"distance does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 3.b: Reading data in tabular format \n",
    "\n",
    "Write a function called ```readTable``` that takes a string called ```filename``` as its argument. The function should read from the file specified in the argument a CSV file formatted as described at the end of Question 2 (you do not necessarily have to answer Question 2 in order to do this; you can create one such file containing arbitrary values using an editor). The function should return a dictionary with the filenames as its keys; the value associated to each key should be a tuple of floats, containing in order the percentages of polar, small and hydrophobic AAs, as listed in the file. So for instance, if the CSV file contains the lines used as an example in Question 2, ```readTable``` should return a dictionary containing at least the following items: \n",
    "```\n",
    "{ \"Pxxx.fasta\": (0.52, 0.22, 0.33),  \"Qx3Z.fas\": (0.47, 0.35, 0.38),\n",
    "... }\n",
    "```\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q3b_ans - Your answer here - do not edit this comment\n",
    "def readTable(filename):\n",
    "    table = {}\n",
    "    with open(filename) as f:\n",
    "        for line in f:\n",
    "            line = line.strip()\n",
    "            if not line.startswith(\"#\"):\n",
    "                parts = line.split(\",\")\n",
    "                name = parts[0]\n",
    "                p = float(parts[1])\n",
    "                s = float(parts[2])\n",
    "                h = float(parts[3])\n",
    "                table[name] = (p, s, h)\n",
    "    return table\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'readTable' in globals(), \"readTable not defined - check your spelling\"\n",
    "assert inspect.isfunction(readTable), \"readTable is not a function\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Question 3.c: Computing a distance matrix \n",
    "\n",
    "Write a function called ```distanceMatrix``` that takes as its argument three strings called ```inputfile```, ```outputfile``` and ```metric```, used to pass the names of the input and output file and for the choice of a metric. The function should use ```readTable``` to read from the input file CSV data created as specified at the end of Question 2 (again, you do not necessarily have to answer Question 2 in order to do this; you can create a CSV file with made-up data using an editor). Suppose data for N proteins are read. Your function should then create an output TSV file containing a matrix of size NxN (plus one row and one column for labels). The rows and columns of the matrix should correspond to individual protein file names, so that each matrix entry corresponds to a pair of proteins, say Pxxx and Pyyy. Such entry should contain the distance between the ```(polar, small, hydrophobic)``` tuples (considered as 3 dimensional vectors) corresponding to Pxxx and Pyyy; the ```metric``` parameter should select which distance in computed, as in Question 3.a above. If done correctly, your matrix should be symmetric and have zeroes on the diagonal. Output the matrix in TSV format with row and column labels as in the following 3-protein example (that contains random numbers and filenames):\n",
    "```\n",
    "# Filename      Pxxx.fas  Pyyy.fas  Pzzz.fas\n",
    "Pxxx.fas        0.00      2.34      1.51\n",
    "Pyyy.fas        2.34      0.00      1.82 \n",
    "Pzzz.fas        1.51      1.82      0.00\n",
    "\n",
    "```\n",
    "The exact alignment is not important, as long as the data are separated by tabs and the first line starts with a hash (```#```). Likewise, the order in which the proteins are listed is not important, provided the same order is used along the rows and along the columns. Do not add any quotes or other spurious characters. Your function should not return any value."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q3c_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def distanceMatrix(inputfile, outputfile, metric):\n",
    "    # 1) read table of filename -> (p, s, h)\n",
    "    data = readTable(inputfile)\n",
    "\n",
    "    # 2) choose an order for the proteins\n",
    "    names = list(data.keys())   # or: sorted(data.keys())\n",
    "\n",
    "    # 3) write the TSV\n",
    "    with open(outputfile, 'w') as out:\n",
    "        # header line (starts with #)\n",
    "        out.write(\"# Filename\\t\" + \"\\t\".join(names) + \"\\n\")\n",
    "\n",
    "        # rows\n",
    "        for i in range(len(names)):\n",
    "            row_name = names[i]\n",
    "            row_values = [row_name]   # first cell = row label\n",
    "            for j in range(len(names)):\n",
    "                col_name = names[j]\n",
    "                # compute distance between two 3D vectors\n",
    "                d = distance(data[row_name], data[col_name], metric)\n",
    "                row_values.append(f\"{d:.2f}\")\n",
    "            out.write(\"\\t\".join(row_values) + \"\\n\")\n",
    "    # no return\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Test code\n",
    "import inspect\n",
    "assert 'distanceMatrix' in globals(), \"distanceMatrix not defined - check your spelling\"\n",
    "assert inspect.isfunction(distanceMatrix), \"distanceMatrix is not a function\"\n",
    "_sig=inspect.signature(distanceMatrix)\n",
    "for _par in ['inputfile', 'outputfile', 'metric']:\n",
    "    assert _par in _sig.parameters, f\"distanceMatrix does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### An application of this type of analysis"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now that you have this code running, try downloading a few FASTA sequences for the [antifreeze proteins](https://pdb101.rcsb.org/motm/120) of cold water fish. Then download the sequences of other families of related proteins (eg Hemoglobin, Insulin and P53) from other species. Process these sequences according to Questions 3 and 4. Have a look at the resulting distance matrix - is any of these groups of proteins characterised by a distinctive pattern of usage of aminoacids? NOTE: no marks are assigned for this section."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Question 4: String alignment [40 marks]"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Question 4.a Write a scoring object \n",
    "\n",
    "Define a class called ```Scoring``` that  implements a scoring matrix for protein sequence alignment. The constructor should take an argument called ```matrix``` that can either be a string specifying the name of a standard matrix or a dictionary specifying custom weights.\n",
    "\n",
    "If ```matrix``` is a string, the constructor should arrange for the ```Scoring``` object to use the corresponding standard matrix, or raise a ```ValueError``` if that is not available. You have an option to load the matrix from a file (include the file with your submission) or use the matrices included with BioPython. Implement at least the  BLOSUM45 and BLOSUM62 matrices.\n",
    "\n",
    "If ```matrix``` is a dictionary, it should be in the following format: ```{(<res_1>, <res_2>): <score>, ('res_3', 'res_4'): <score>}``` where ```<res_n>``` stands for a 1-letter aminoacid code. The first element of a each tuple should precede the second element in alphabetical order or be equal to it. Scores for substitutions not explicitely listed in the dictionary and not obtainable by symmetry should be interpreted as being 1 in case of a match, and 0 in case of a mismatch. Thus passing an empty dictionary as ```matrix``` should result in the identity matrix being used.\n",
    "\n",
    "The ```Scoring``` class should implement a ```match``` method taking two arguments for the two residues to be scored. It should return the matching score for the two residues. The method should work irrespective of how the matrix was specified and regardless of whether the first argument preceeds the second in alphabetical order, is equal to it or follows it.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q4a_ans - Your answer here - do not edit this comment\n",
    "class Scoring:\n",
    "    def __init__(self, matrix):\n",
    "        # load matrix depending on type\n",
    "        if isinstance(matrix, str):\n",
    "            from Bio.SubsMat import MatrixInfo\n",
    "            if matrix.upper() == \"BLOSUM62\":\n",
    "                self.matrix = MatrixInfo.blosum62\n",
    "            elif matrix.upper() == \"BLOSUM45\":\n",
    "                self.matrix = MatrixInfo.blosum45\n",
    "            else:\n",
    "                raise ValueError(\"Matrix not available\")\n",
    "        elif isinstance(matrix, dict):\n",
    "            self.matrix = matrix\n",
    "        else:\n",
    "            raise ValueError(\"Matrix must be string or dict\")\n",
    "\n",
    "    def match(self, r1, r2):\n",
    "        # sort residues alphabetically so ('A','R') == ('R','A')\n",
    "        key = tuple(sorted((r1, r2)))\n",
    "        if key in self.matrix:\n",
    "            return self.matrix[key]\n",
    "        elif r1 == r2:\n",
    "            return 1\n",
    "        else:\n",
    "            return 0\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Your code should pass this test when run on a fresh kernel\n",
    "import inspect\n",
    "assert \"Scoring\" in globals(), \"Scoring not defined - check your spelling\"\n",
    "assert inspect.isfunction(Scoring.match), \"Scoring does not define a match method\"\n",
    "print(\"OK\") "
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Question 4.b: Write a simple string alignment algorithm \n",
    "\n",
    "Write a function ```simple_align``` that aligns two aminoacid sequences using the one-step lookahead algorithm described in the Assignment Background. The function should take the following arguments:\n",
    "* ```sequences```: a tuple with the two sequences to be aligned as strings\n",
    "* ```scoring```: a ```Scoring``` object, as defined above \n",
    "* ```gap```: the (linear) gap penalty, typically a negative value (eg -1).\n",
    "\n",
    "Your fuction should return a tuple of the form ```(<aln1>, <aln2>, <score>)``` where ```<aln1>``` and ```<aln2>``` stand for the two aligned sequences (aligned strings should be of the same length, with gaps marked as minus signs) and ```<score>``` is the alignment score.\n",
    "\n",
    "NOTE: if you were unable to implement a functional ```Scoring``` class, code ```simple_align``` so that:\n",
    "* it uses a hard-coded identity matrix for scoring, and\n",
    "* it raises a ```NotImplementedError``` unless the ```scoring``` parameter is equal to ```None```.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q4b_ans - Your answer here - do not edit this comment\n",
    "def simple_align(sequences, scoring=None, gap=-1):\n",
    "    s1, s2 = sequences\n",
    "    i = 0\n",
    "    j = 0\n",
    "    aln1 = \"\"\n",
    "    aln2 = \"\"\n",
    "    total_score = 0\n",
    "\n",
    "    # if no scoring system provided, use simple identity\n",
    "    if scoring is None:\n",
    "        def score_fn(a, b):\n",
    "            return 1 if a == b else 0\n",
    "    else:\n",
    "        score_fn = scoring.match\n",
    "\n",
    "    while i < len(s1) or j < len(s2):\n",
    "        # if both have residues\n",
    "        if i < len(s1) and j < len(s2):\n",
    "            match = score_fn(s1[i], s2[j])\n",
    "        else:\n",
    "            match = -999   # invalid if one seq empty\n",
    "\n",
    "        # gaps\n",
    "        gap1 = gap if j < len(s2) else -999\n",
    "        gap2 = gap if i < len(s1) else -999\n",
    "\n",
    "        # pick the best move\n",
    "        best = max(match, gap1, gap2)\n",
    "\n",
    "        if best == match:\n",
    "            aln1 += s1[i]\n",
    "            aln2 += s2[j]\n",
    "            total_score += match\n",
    "            i += 1\n",
    "            j += 1\n",
    "        elif best == gap1:\n",
    "            aln1 += \"-\"\n",
    "            aln2 += s2[j]\n",
    "            total_score += gap\n",
    "            j += 1\n",
    "        else:  # best == gap2\n",
    "            aln1 += s1[i]\n",
    "            aln2 += \"-\"\n",
    "            total_score += gap\n",
    "            i += 1\n",
    "\n",
    "    return (aln1, aln2, total_score)\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Your code should pass this test when run on a fresh kernel \n",
    "import inspect\n",
    "assert 'simple_align' in globals(), \"simple_align not defined - check your spelling\"\n",
    "assert inspect.isfunction(simple_align), \"simple_align is not a function\"\n",
    "_sig=inspect.signature(simple_align)\n",
    "for _par in ['sequences', 'scoring', 'gap']:\n",
    "    assert _par in _sig.parameters, f\"simple_align does not take a {_par} parameter\"\n",
    "print(\"OK\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Question 4.c: \"Seeding\" the alignment\n",
    "\n",
    "Write a function called ```seeded_simple_align``` that takes a partial alignment (from the start of two sequences) and extends it to a complete global alignment. Your function should take the same arguments taken by ```simple_align```, followed by argument ```seed``` that should be equal to a tuple containing the partial alignment, with gaps encoded as minus signs. Your code should check\n",
    "* that strings passed as ```seed```, minus the gaps, are each a prefix of the corresponding strings passed as sequences; \n",
    "* that the two ```seed``` strings are of the same length.\n",
    "Your code should raise a ```ValueError``` if either of these two checks fails. It should then use ```simple_align``` to extend the partial alignment to a total alignment, returning the complete global alignment with its total score in the same format as ```simple_align```.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q4c_ans - Your answer here - do not edit this comment\n",
    "\n",
    "def seeded_simple_align(sequences, scoring=None, gap=-1, seed=(\"\", \"\")):\n",
    "    s1, s2 = sequences\n",
    "    seed1, seed2 = seed\n",
    "\n",
    "    # 1) checks\n",
    "    if len(seed1) != len(seed2):\n",
    "        raise ValueError(\"Seed strings must have the same length.\")\n",
    "\n",
    "    core1 = seed1.replace(\"-\", \"\")\n",
    "    core2 = seed2.replace(\"-\", \"\")\n",
    "\n",
    "    if not s1.startswith(core1) or not s2.startswith(core2):\n",
    "        raise ValueError(\"Seed cores must be prefixes of the sequences.\")\n",
    "\n",
    "    # optional: forbid \"--\" columns\n",
    "    for a, b in zip(seed1, seed2):\n",
    "        if a == \"-\" and b == \"-\":\n",
    "            raise ValueError(\"Seed cannot contain a double gap column.\")\n",
    "\n",
    "    # 2) scoring function (same rule as simple_align)\n",
    "    if scoring is None:\n",
    "        def score_fn(a, b):\n",
    "            return 1 if a == b else 0\n",
    "    else:\n",
    "        score_fn = scoring.match\n",
    "\n",
    "    # 3) score the seed\n",
    "    seed_score = 0\n",
    "    for a, b in zip(seed1, seed2):\n",
    "        if a != \"-\" and b != \"-\":\n",
    "            seed_score += score_fn(a, b)\n",
    "        elif a == \"-\" and b != \"-\":\n",
    "            seed_score += gap\n",
    "        elif a != \"-\" and b == \"-\":\n",
    "            seed_score += gap\n",
    "        # (both '-' already blocked)\n",
    "\n",
    "    # 4) compute suffixes to align\n",
    "    i = len(core1)\n",
    "    j = len(core2)\n",
    "    tail1 = s1[i:]\n",
    "    tail2 = s2[j:]\n",
    "\n",
    "    # 5) extend with simple_align\n",
    "    t_aln1, t_aln2, t_score = simple_align((tail1, tail2), scoring, gap)\n",
    "\n",
    "    # 6) combine\n",
    "    aln1 = seed1 + t_aln1\n",
    "    aln2 = seed2 + t_aln2\n",
    "    total = seed_score + t_score\n",
    "\n",
    "    return (aln1, aln2, total)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Your code should pass this test when run on a fresh kernel \n",
    "import inspect\n",
    "assert 'seeded_simple_align' in globals(), \"seeded_simple_align not defined - check your spelling\"\n",
    "assert inspect.isfunction(seeded_simple_align), \"seeded_simple_align is not a function\"\n",
    "_sig=inspect.signature(seeded_simple_align)\n",
    "for _par in ['sequences', 'scoring', 'gap', 'seed']:\n",
    "    assert _par in _sig.parameters, f\"seeded_simple_align does not take a {_par} parameter\"\n",
    "print('OK')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Question 4.d: Suboptimality of the simple alignment algorithm \n",
    "Show that the simple alignment algorithm implemented above does not always yield an optimal alignment by exhibiting two sequences, a scoring matrix and gap penalty of your choice and a partial alignment such that seeding the algorithm with the partial alignment produces a better result than running the algorithm without any \"nudge\". Document your solution with comments as required.\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Q4d_ans - Your answer here - do not edit this comment\n",
    "\n",
    "# Identity scoring via simple_align(scoring=None), gap = -1\n",
    "s1 = \"ACD\"\n",
    "s2 = \"AQCD\"\n",
    "gap_pen = -1\n",
    "\n",
    "# Unseeded (greedy) alignment\n",
    "aln1_u, aln2_u, score_u = simple_align((s1, s2), scoring=None, gap=gap_pen)\n",
    "print(\"Unseeded:\")\n",
    "print(aln1_u)\n",
    "print(aln2_u)\n",
    "print(\"Score =\", score_u)   # expected 0\n",
    "\n",
    "# Seeded alignment (force early gap opposite Q)\n",
    "seed = (\"A-\", \"AQ\")  # valid: \"A\" and \"AQ\" are prefixes; same length\n",
    "aln1_s, aln2_s, score_s = seeded_simple_align((s1, s2), scoring=None, gap=gap_pen, seed=seed)\n",
    "print(\"\\nSeeded:\")\n",
    "print(aln1_s)\n",
    "print(aln2_s)\n",
    "print(\"Score =\", score_s)   # expected 2\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {
    "collapsed": true,
    "jupyter": {
     "outputs_hidden": true
    }
   },
   "source": [
    "## Examiners\n",
    "\n",
    "Dr Fabrizio Smeraldi *(f.smeraldi@qmul.ac.uk)*; Prof Conrad Bessant *(c.bessant@qmul.ac.uk)*"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.19"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
